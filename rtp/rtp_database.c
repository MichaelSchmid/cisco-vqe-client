/**------------------------------------------------------------------------
 * @brief
 * RTP database functions.
 *
 * @file
 * rtp_database.c
 *
 * April 2007, Mike Lague.
 *
 * Copyright (c) 2007-2008 by cisco Systems, Inc.
 * All rights reserved.
 *-------------------------------------------------------------------------
 */
#include "utils/vam_util.h"

#include "rtp_database.h"
#include "rtp_util.h"

#include "../include/utils/tree_plus.h"

/*
 * rtp_cmp_cname
 *
 * Compare CNAME values (as null-terminated strings).
 * Note that a NULL ptr for CNAME represents the lowest possible CNAME value.
 * 
 * Parameters:
 * cn1           -- ptr to first CNAME
 * cn2           -- ptr to second CNAME
 * Returns:
 * <0  --the first CNAME is less than the second
 *  0  --the first CNAME is equal to the second
 * >0  --the first CNAME is greater than the second
 */
int rtp_cmp_cname (char *cn1, char *cn2)
{
    if (!cn1) {
        /* cn1 is NULL: return <0 if cn2 is non-NULL, =0 if cn2 is NULL */
        return (cn2 ? -1 : 0);
    } else if (!cn2) {
        /* cn1 is non-NULL, cn2 is NULL: return >0 */
        return (1);
    } else {
        return (strncmp(cn1, cn2, RTCP_MAX_CNAME + 1));
    }
}

/*
 * rtp_cmp_member
 *
 * Compare the key (SSRC+CNAME) values of two members,
 * Note that a NULL ptr for CNAME represents the lowest possible CNAME value.
 * 
 * This comparison function is used during member RB tree operations (search,
 * insertion, etc.) to determine the "key" of the member and its order relative
 * to the keys of other members. This function is specified as the comparison
 * function at the time the  member tree functions are generated (with the 
 * RBP_GENERATE macro (see below).
 *
 * Parameters:
 * m1           -- ptr to data for the first member
 * m2           -- ptr to data for the second member
 * Returns:
 * <0  --the first member's key is less than that of the second
 *  0  --the first member's key is equal to that of the second
 * >0  --the first member's key is greater than that of the second
 */
static int rtp_cmp_member (rtp_member_t *m1, rtp_member_t *m2)
{
    if (!m1) {
        /* m1 is NULL: return < if m2 is non-NULL, = if m2 is NULL */
        return (m2 ? -1 : 0) ;
    } else if (!m2) {
        /* m1 is non-NULL, m2 is NULL: return > */
        return (1);
    } else if (m1->ssrc < m2->ssrc) {
        return (-1);
    } else if (m1->ssrc > m2->ssrc) {
        return (1);
    } else {
        /* ssrc's are equal: compare CNAMEs */
        return (rtp_cmp_cname(m1->sdes[RTCP_SDES_CNAME], 
                              m2->sdes[RTCP_SDES_CNAME]));
    }
}

/*
 * rtp_member_tree_t__RB_*
 *
 * Database functions for the RB tree of RTP members,
 * Code for all necessary functions is generated by the 
 * RBP_GENERATE macro.
 */

/*
 * ignore SA warnings from RBP_GENERATE, since it's based
 * on RB_GENERATE, which is 3rd-party source we shouldn't 
 * change: warnings have been determined to be benign.
 * sa_ignore is needed _after_ the macro invocation, as well as before,
 * to deal with a warning about a missing else clause not produced 
 * by the macro.
 */
/*sa_ignore */
VQE_RBP_GENERATE(rtp_member_tree_t_, rtp_member_t_, member_entry, rtp_cmp_member);
/*sa_ignore */

/*
 * rtp_first_member
 *
 * Get the first member in the member tree (in SSRC+CNAME order)
 *
 * Parameters:
 * sess             --ptr to per-session data
 * Returns:         --a ptr to the member data, 
 *                    or NULL if there are no members
 */
rtp_member_t *rtp_first_member (rtp_session_t *sess)
{
    return (VQE_RB_MIN(rtp_member_tree_t_, &sess->member_tree));
}

/*
 * rtp_next_member
 *
 * Get the next member in the member tree, following a specified member
 * (in SSRC+CNAME order)
 *
 * Parameters:
 * sess             --ptr to per-session data
 * member           --ptr to per-member data
 * Returns:         --ptr to next higher member, 
 *                    or NULL if there is no such member.
 */
rtp_member_t *rtp_next_member (rtp_session_t *sess,
                               rtp_member_t *member)
{
    return (VQE_RB_NEXT(rtp_member_tree_t_, &sess->member_tree, member));
}

/*
 * rtp_first_member_with_ssrc
 *
 * Find the member with the lowest SSRC+CNAME key value,
 * whose SSRC is equal to the specified SSRC.
 *
 * Parameters:
 * sess                --ptr to session data
 * ssrc                --SSRC value to search for (host order)
 * Returns:            ptr to member, if it exists; else NULL.
 */
rtp_member_t *rtp_first_member_with_ssrc (rtp_session_t *sess,
                                          uint32_t ssrc)
{
    rtp_member_t search;
    rtp_member_t *match;

    if (!sess) {
        return (NULL);
    }

    search.ssrc = ssrc;
    search.sdes[RTCP_SDES_CNAME] = NULL;

    match = VQE_RB_FINDGE(rtp_member_tree_t_, &sess->member_tree, &search);
    return ((match && match->ssrc == ssrc) ? match : NULL);
}

/*
 * rtp_next_member_with_ssrc
 *
 * Given a member with a SSRC+CNAME key value,
 * find the next member in key order (if any), with the same SSRC value.
 *
 * Parameters:
 * member              --ptr to member data
 * Returns:            ptr to member, if it exists; else NULL.
 */
rtp_member_t *rtp_next_member_with_ssrc (rtp_session_t *sess,
                                         rtp_member_t *member)
{
    rtp_member_t *match;
    if (!(sess && member)) {
        return (NULL);
    }
    match = VQE_RB_NEXT(rtp_member_tree_t_, &sess->member_tree, member);
    return ((match && match->ssrc == member->ssrc) ? match : NULL);
}

/* 
 * rtp_sending_member_with_ssrc
 *
 * Find the sending member (if any) with the specified SSRC value.
 * The application must ensure that at most one such member exists.
 *
 * Parameters:
 * sess                --ptr to session data
 * ssrc                --SSRC value (host order)
 * Returns:            ptr to member, if it exists; else NULL.
 */
rtp_member_t *rtp_sending_member_with_ssrc (rtp_session_t *sess,
                                            uint32_t ssrc)
{
    rtp_member_t *member = NULL;
    
    for (member = rtp_first_member_with_ssrc(sess, ssrc) ;
         member ;
         member = rtp_next_member_with_ssrc(sess, member)) {
        if (!(member->flags & RTP_MEMBER_FLAG_RCVR_ONLY)) {
            /* this is NOT "receiver only", so it's the sending member */
            break;
        }
    }
    
    return (member);
}
                                            
/*
 * rtp_find_member
 *
 * Find a member by SSRC+CNAME
 *
 * Parameters:
 * sess                --ptr to session data
 * ssrc                --SSRC value (host order)
 * cname               --CNAME (as null-terminated string)
 * Returns:            ptr to member, if it exists; else NULL.
 */
rtp_member_t *rtp_find_member (rtp_session_t *sess,
                               uint32_t ssrc,
                               char *cname)
{
    rtp_member_t search;

    if (!sess) {
        return (NULL);
    }
    search.ssrc = ssrc;
    search.sdes[RTCP_SDES_CNAME] = cname;

    return (VQE_RB_FIND(rtp_member_tree_t_, &sess->member_tree, &search));
}

/*
 * rtp_add_member
 *
 * Add a member to the RTP per-session member database
 *
 * Parameters:
 * sess                --ptr to session data
 * member              --ptr to member data
 * Returns:            TRUE if successful, else FALSE.
 *                     Note that FALSE typically means that a member
 *                     with the same SSRC+CNAME value already exists 
 *                     in the database.
 */
boolean rtp_add_member (rtp_session_t *sess,
                        rtp_member_t *member)
{
    rtp_member_t *result = VQE_RB_INSERT(rtp_member_tree_t_,
                                     &sess->member_tree,
                                     member);
    return (result == NULL ? TRUE : FALSE);
}

/*
 * cnamecpy
 *
 * Safely copy a CNAME
 *
 * Parameters:
 * dst          -- ptr to destination string
 * src          -- ptr to src string
 */
static void cnamecpy (char *dst, const char *src)
{
    strncpy(dst, src, RTCP_MAX_CNAME + 1);
    dst[RTCP_MAX_CNAME] = '\0';
}

/*
 * rtp_update_member_cname
 *
 * Update the CNAME of a member, making the necessary adjustments
 * to the database. This is typically used in the following scenario:
 * . RTP data arrives: the CNAME is not known, but a member with the
 *   SSRC of the data packet is added to the database, if necessary.
 * . an RTCP compound packet for the given SSRC arrives: the CNAME
 *   is now known, and the database must be updated accordingly.
 *
 * Parameters:
 * sess                --ptr to session data
 * member              --ptr to member data
 * cname               --CNAME (as null-terminated string)
 * Returns:            TRUE if successful, else FALSE.
 */
boolean rtp_update_member_cname (rtp_session_t *sess,
                                 rtp_member_t  *member,
                                 char *cname)
{
    char *old_cname;
    char *failure_reason = "<unspecified>";
    char old_cname_value[RTCP_MAX_CNAME+1];
    char addr[INET_ADDRSTRLEN];
    boolean allocated_sdes = FALSE;

    if (!(sess && member && cname)) {
        return (FALSE);
    }

    if (rtp_cmp_cname(member->sdes[RTCP_SDES_CNAME], cname) == 0) {
        return (TRUE);
    } 

    if (member->sdes[RTCP_SDES_CNAME]) {
        cnamecpy(old_cname_value, member->sdes[RTCP_SDES_CNAME]);
        old_cname = old_cname_value;
    } else {
        old_cname = NULL;
    }

    rtp_remove_member(sess, member);
    if (old_cname == NULL) {
        member->sdes[RTCP_SDES_CNAME] = 
            rtcp_new_object(sess->rtcp_mem, RTCP_OBJ_SDES);
        if (member->sdes[RTCP_SDES_CNAME] == NULL) {
            failure_reason = "no SDES memory";
            goto rollback;
        } else {
            allocated_sdes = TRUE;
        }
    }
    cnamecpy(member->sdes[RTCP_SDES_CNAME], cname);
    if (rtp_add_member(sess, member)) {
        return (TRUE);
    } else {
        failure_reason = "failed add member to per-session tree";
    }

 rollback:
    RTP_SYSLOG(RTCP_CNAME_UPDATE_FAILURE,
               uint32_ntoa_r(rtp_get_session_id_addr(sess->session_id),
                             addr, sizeof(addr)),
               ntohs(rtp_get_session_id_port(sess->session_id)),
               member->ssrc,
               old_cname ? old_cname : "<none>",
               cname ? cname : "<none>",
               failure_reason);
    if (allocated_sdes) {
        rtcp_delete_object(sess->rtcp_mem, RTCP_OBJ_SDES, 
                           member->sdes[RTCP_SDES_CNAME]);
        member->sdes[RTCP_SDES_CNAME] = NULL;
    }
    if (old_cname) {
        cnamecpy(member->sdes[RTCP_SDES_CNAME], old_cname);
    }
    if (!rtp_add_member(sess, member)) {
        /* 
         * we should be able to add the member back the way it was
         */
        RTP_SYSLOG(RTCP_CNAME_ROLLBACK_FAILURE,
                   uint32_ntoa_r(rtp_get_session_id_addr(sess->session_id),
                                 addr, sizeof(addr)),
                   ntohs(rtp_get_session_id_port(sess->session_id)),
                   member->ssrc,
                   old_cname ? old_cname : "<none>",
                   cname ? cname : "<none>");
    }
    return (FALSE);
}

/*
 * rtp_update_member_ssrc
 *
 * Update the SSRC of a member, 
 * making the necessary adjustments to the database.
 */

boolean rtp_update_member_ssrc (rtp_session_t *sess,
                                rtp_member_t  *member,
                                uint32_t ssrc)
{
    uint32_t old_ssrc = member->ssrc;
    char addr[INET_ADDRSTRLEN];

    rtp_remove_member(sess, member);
    member->ssrc = ssrc;
    if (rtp_add_member(sess, member)) {
        return (TRUE);
    } else {
        /* put the member back, with the old ssrc */
        member->ssrc = old_ssrc;
        if (!rtp_add_member(sess, member)) {
            RTP_SYSLOG(RTCP_SSRC_ROLLBACK_FAILURE,
                       uint32_ntoa_r(rtp_get_session_id_addr(sess->session_id),
                                     addr, sizeof(addr)),
                       ntohs(rtp_get_session_id_port(sess->session_id)),
                       member->ssrc,
                       member->sdes[RTCP_SDES_CNAME] ? 
                       member->sdes[RTCP_SDES_CNAME] : "<none>",
                       ssrc);
        }
        return (FALSE);
    }
}

/*
 * rtp_remove_member
 *
 * Remove a member from the RTP per-session member database
 *
 * Parameters:
 * sess                --ptr to session data
 * member              --ptr to member data
 * Returns:            TRUE if successful, else FALSE.
 */
void rtp_remove_member (rtp_session_t *sess,
                        rtp_member_t  *member)
{
    rtp_member_t *result = NULL;

    result = VQE_RB_REMOVE(rtp_member_tree_t_,
                       &sess->member_tree,
                       member);
}
