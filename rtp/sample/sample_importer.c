/* $Id$
 * $Source$
 *------------------------------------------------------------------
 *
 * Sample Importer
 * 
 * Apr 26, 2007, Carol Iturralde
 *
 * Copyright (c) 2006-2008 by cisco Systems, Inc.
 * All rights reserved.
 *
 * Description:
 *
 * A utility program to receive and print reports generated by
 * the VQE-S Exporter. Furthermore, it has the option to dump the
 * reports to a pcap file.
 *
 * To build: Do "make" in the sample directory
 *
 * The program will 
 *  o create a TCP socket, 
 *  o bind to the above local ip-addr and tcp-port,
 *  o listen for an incoming connection from the RTCP Exporter 
 *      (running on VQE-S).
 *  o accept incoming connection
 *  o recv exported data records on the TCP socket
 *  o print these records to stdout
 *  o dump the reports to a pcap file
 *
 *
 * There is an additional optional parameter:
 *
 *     [-c <addr-1:port-1> [...,<addr-n:port-n>] ]
 *
 * The -c option provides an output filter -- to cause the exporter
 * only print records to stdout if they correspond to 
 * 
 * 
 *------------------------------------------------------------------
 * $Log$
 *------------------------------------------------------------------
 * $Endlog$
 */

//#include <signal.h>

#include "vqe_pcap.h"

#include "sample_rtp_session.h"
#include "sample_rtp_dataplane.h"
#include "sample_rtp_utils.h"
#include "exp.h"


#define MAX_FILE_NAME_LENGTH 256

static uint64_t tot_pkts_recd = 0;
static uint64_t tot_pkts_matched = 0;

#define RCV_BUF_SIZE 1500

static char rcvbuf[RCV_BUF_SIZE];

static char pcapbuf[EXP_BUF_SIZE];
static uint64_t max_pcap_size_used = 0;
static uint64_t max_pcap_size_allowed = 100000000;
#define PCAP_UPPER_LIMIT 10000000
#define OVER_HEAD \
    sizeof(pcaprec_hdr_t) + sizeof(hdr_udp_t) + \
    sizeof(hdr_ip_t) + sizeof(hdr_ethernet_t);

#define IPADDR(b0,b1,b2,b3) (htonl((b0 << 24) | (b1 << 16) | (b2 << 8) | b3))
#define IPPORT(p) (htons(p))

#define DEFAULT_FILENAME "/tmp/vqes.pcap"

/* SIGCHLD handler */
void intrup(int dummy) {}

/* forward declaration */
void handle_accepted_socket(int32_t new_fd, 
                            uint32_t instance, 
                            boolean verbose,
                            boolean display_reports,
                            FILE *fp);

static void print_usage (void) 
{
    printf("Importer usage: importer \n"
           "                   [-l <addr>:<port> (default: 127.0.0.1:8312)]\n"
           "                   [-c <addr1:port1>[...,<addrn:portn>]]\n"
           "                   [-p (print out RTCP reports)]\n"
           "                   [-o pcap_filename (default:/tmp/vqes.pcap)]\n"
           "                   [-m max_pcap_file_size (default: 100000 kb)]\n"
           "                   [-d (disable pcap output)]\n"
           "                   [-v (verbose display; use with -p)]\n");
}

static uint16_t get_exp_length(exp_base_header_t *base_p)
{
    return ((base_p->ver_flags == EXP_BASE_VER_FLAGS) ?
            base_p->length : ntohs(base_p->length));
}

typedef struct addr_filter_ {
    uint32_t addr;
    uint16_t port;
} addr_filter;

#define MAX_FILTERS 10

static addr_filter filters[MAX_FILTERS];
static int num_filters = 0;


boolean dest_matches_filter (uint32_t stream_dest_addr, 
			     uint16_t stream_dest_port)
{
    int i;

    /*
     * If no filters are defined, just print
     */
    if (num_filters == 0) {
	return (TRUE);
    }


    /*
     * Filters are defined.  If this (addr, port) matches one of
     * them, then okay to print.
     */
    for (i = 0; i < num_filters ; i++) {
	if (stream_dest_addr == filters[i].addr &&
	    stream_dest_port == filters[i].port) {
	    tot_pkts_matched++;
	    return (TRUE);
	}
    }

    /*
     * Didn't match any of the defined filters - don't print.
     */
    return (FALSE);
}


int main (int argc, char **argv)
{
    int32_t fd;
    int32_t new_fd = -1;
    int on = 1;

    struct sockaddr_in remote_addr;     /* Addr/Port from which reports Exported */
    size_t             remote_addr_len;

    in_addr_t listen_addr = IPADDR(127, 0, 0, 1);
    in_port_t listen_port = IPPORT(8312);

    char addr_str[MAX_IP_ADDR_LEN + 1];
    char port_str[MAX_PORT_LEN + 1];
    char *filter;
    int c = 0;

    boolean output_pcap_file = TRUE;
    char pcap_filename[MAX_FILE_NAME_LENGTH];
    
    addr_str[0] = '\0';
    port_str[0] = '\0';

    boolean verbose = FALSE;
    boolean display_reports = FALSE;

    pid_t process_id;
    uint32_t instance = 1;
    FILE *pcap_fp = 0;
    struct sigaction sa;

    strncpy(pcap_filename, DEFAULT_FILENAME, MAX_FILE_NAME_LENGTH);
    while ((c = getopt(argc, argv, "l:c:vhdpo:m:")) != EOF) {
	switch (c) {
	case 'l':
            if (sscanf(optarg, "%15[^:]:%5s", 
		       addr_str, port_str) != 2) {
		print_usage();
		return (-1);
	    }
	    listen_addr = inet_addr(addr_str);
	    listen_port = htons((in_port_t)(atoi(port_str)));

	    break;

        case 'c':
            filter = strtok(optarg, ",");

            while((filter != NULL) && (num_filters < MAX_FILTERS)) {

                if (sscanf(filter, "%15[^:]:%5s", addr_str, port_str) != 2) {
                    print_usage();
                    return (-1);
                }
                filters[num_filters].addr = inet_addr(addr_str);
                filters[num_filters].port = htons((in_port_t)(atoi(port_str)));
                printf("Added filter for printing channel %s:%s...\n", 
                       addr_str, port_str);
                num_filters++;
                filter = strtok(NULL, ",");
            }
	    break;

        case 'o':
            strncpy(pcap_filename, optarg, MAX_FILE_NAME_LENGTH);
            break;

        case 'd':
            output_pcap_file = FALSE;
            break;

        case 'm':
            max_pcap_size_allowed = atoi(optarg);
            printf("Setting the max size for pcap file to %llu kb\n",
                   max_pcap_size_allowed);
            if (max_pcap_size_allowed > PCAP_UPPER_LIMIT) {
                max_pcap_size_allowed = PCAP_UPPER_LIMIT;
                printf("Limitting the max size for pcap file to %llu kb\n",
                       max_pcap_size_allowed);
            }

            /* Change it to bytes from kb */
            max_pcap_size_allowed = max_pcap_size_allowed * 1000;
            break;

        case 'v':
            verbose = TRUE;
            break;

        case 'p':
            display_reports = TRUE;
            break;

        case 'h':
            print_usage();
            return (-1);

	default:
	    print_usage();
	    return (-1);
	}
    }

    /* Open a pcap file for outputing RTCP report if enabled */
    if (output_pcap_file) {
        pcap_fp = vqe_pcap_open_file(pcap_filename);
        if (pcap_fp == NULL) {
            fprintf(stderr, "Importer: Failed to open the pcap file %s "
                    "for write\n",
                    pcap_filename);
            return (-1);
        }
    }

    /* Create up TCP Socket */
    if ((fd = socket(PF_INET, SOCK_STREAM, 0)) == -1) {
        perror("socket");
        return (-1);
    }

    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) {
        perror("setsockopt");
        goto bail;
    }

    struct sockaddr_in saddr;
    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = listen_addr;
    saddr.sin_port = listen_port;    

    if (bind(fd, (struct sockaddr *) &saddr, sizeof(saddr)) == -1) {
        perror("bind");
        goto bail;
    }

    printf("Importer: Listening on %s:%d ...\n", inet_ntoa(saddr.sin_addr), 
	   ntohs(saddr.sin_port));

    if (listen(fd, 3) == -1) {
        perror("listen");
        goto bail;
    }

    printf("Importer: Listen succeeded.  Wait for incoming connects ...)\n");

    sa.sa_handler = intrup;
    /* sa_ignore DISABLE_RETURNS sigemptyset */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    /* sa_ignore DISABLE_RETURNS sigaction */
    sigaction(SIGCHLD, &sa, NULL);

    for(;;) {

	remote_addr_len = sizeof(remote_addr);

	new_fd = accept(fd, (struct sockaddr*)&remote_addr, 
			(size_t *)&remote_addr_len);

	if (new_fd == -1) {
            if (errno == EINTR) {
                goto done;
            } else {
                perror("accept");
                goto bail;
            }
	}
    
	printf("Importer: Received connect from %s:%d\n", 
	       inet_ntoa(remote_addr.sin_addr),
	       ntohs(remote_addr.sin_port));

	process_id = fork();

	if (process_id < 0) {
	    /* fork failed, bail */
	    perror("fork failed");
	    goto bail;
	}

	if (process_id == 0) {
	    /* Child process */
	    handle_accepted_socket(new_fd, instance, verbose, 
                                   display_reports, pcap_fp);
	} else {
	    instance++;
	}
    }

 bail:
    if (output_pcap_file) {
        if (!vqe_pcap_close_file(pcap_fp)) {
            fprintf(stderr, "Failed to close the pcap file %s\n",
                    pcap_filename);
        }
    }
  done:
    close(fd);
    return(-1);
}


void handle_accepted_socket(int32_t new_fd, 
                            uint32_t instance, 
                            boolean verbose,
                            boolean display_rep,
                            FILE *fp)
{
    size_t num_bytes_to_recv;
    ssize_t bytes_received;
    exp_base_header_t        exp_base;
    int rcv_flags = MSG_WAITALL; /* block 'til fill request satisfied */

    exp_rtcp_report_header_t  *exp_report_p;
    exp_rtcp_report_header2_t *exp_report2_p;
    exp_missed_reports_t      *exp_missed_old_p;
    exp_missed_reports_v2_t   *exp_missed_p;

    char *   rtcp_packet_p;
    uint32_t rtcp_packet_len;
    char straddrbuf[INET_ADDRSTRLEN];
    char pktaddrbuf[INET_ADDRSTRLEN];
#define TIMEBUF_LEN 80
    char timebuf[TIMEBUF_LEN];
    ntp64_t rcv_ts;
    uint8_t version;
    ssize_t length;
    uint32_t missed_hi, missed_lo;
    uint64_t missed;
    vqe_pcap_ret_t pcap_ret = VQE_PCAP_SUCCESS;
    uint32_t pcap_len = 0;
    uint32_t pkt_len = 0;

    for (;;) {

        /* Clean up the memory for pcap buffer */
        if (fp) {
            memset(pcapbuf, 0, EXP_BUF_SIZE);
        }
		
	/*
	 * Read common export header
	 */
	num_bytes_to_recv = sizeof(exp_base_header_t);
	
	bytes_received = recv(new_fd, 
			      (void *)&exp_base,
			      num_bytes_to_recv,
			      rcv_flags);
	
	if (bytes_received == 0) {
	    printf("\nImporter-%d: fatal error: received zero bytes\n",
		   instance);
	    goto done;		
	}

	if (bytes_received != num_bytes_to_recv) {
	    printf("\nImporter-%d: fatal error: wrong num bytes received, "
		   "bytes_received = %d, num_bytes_to_recv = %d\n",
		   instance, bytes_received, num_bytes_to_recv);
	    
	    goto done;
	}
	
        if (fp) {
            memcpy(pcapbuf, (char *)&exp_base, bytes_received);
            pcap_len = bytes_received;
        }
	
	tot_pkts_recd++;
	
        if (verbose && display_rep) {
            printf("\n\n");
            printf("------ Exported Packet %llu Received ---(instance %d)---\n",
                   tot_pkts_recd, instance);
	
            /* print out base header contents */
            printf("Common Header:\n");
            printf("  ver_flags = 0x%x, type = %d, length = %d \n\n", 
                   exp_base.ver_flags,
                   exp_base.type,
                   get_exp_length(&exp_base));
	}

	/*
	 * Read remainder of export packet
	 */
        num_bytes_to_recv = (get_exp_length(&exp_base) - 
                             sizeof(exp_base_header_t));
		
	bytes_received = recv(new_fd, 
			      (void *)rcvbuf,
			      num_bytes_to_recv,
			      rcv_flags);
	
	if (bytes_received != num_bytes_to_recv) {
	    printf("\nImporter-%d: fatal error: wrong num bytes received, "
		   "bytes_received = %d, num_bytes_to_recv = %d\n",
		   instance, bytes_received, num_bytes_to_recv);
	    goto done;
	}
	
        if (fp) {
            memcpy(&pcapbuf[pcap_len], rcvbuf, bytes_received);
            pcap_len += bytes_received;	
        }

        if (display_rep) {
            switch (exp_base.type) {
	    
            case EXP_BASE_TYPE_RTCP_REPORT:
	    
                exp_report_p = (exp_rtcp_report_header_t*)rcvbuf;
		
                if (dest_matches_filter(exp_report_p->stream_dest_addr,
                                        exp_report_p->stream_dest_port)) {
                    
                    rcv_ts.upper = ntohl(exp_report_p->orig_send_time_u);
                    rcv_ts.lower = ntohl(exp_report_p->orig_send_time_l);

                    printf("RTCP Compound Packet: rcvd at %s\n",
                           abs_time_to_str(ntp_to_abs_time(rcv_ts), 
                                           timebuf, sizeof(timebuf)));
                    if (verbose && (tot_pkts_matched > 0)) {
                        printf("  (number %llu to match filters)\n",
                               tot_pkts_matched);
                    }

                    version = (exp_report_p->ver_flags >> 4);

                    if (verbose) {
                        printf("  Proprietary Header:\n");
                        printf("    ver_flags:        0x%x \n",
                               exp_report_p->ver_flags);
                        printf("    stream_type:      %u \n", 
                               exp_report_p->stream_type);
                        printf("    stream_dest_port: %u \n", 
                               ntohs(exp_report_p->stream_dest_port));
                        printf("    stream_dest_addr: %s \n", 
                               uint32_ntoa_r(exp_report_p->stream_dest_addr,
                                             straddrbuf, sizeof(straddrbuf)));
                        printf("    packet_dest_addr: %s \n", 
                               uint32_ntoa_r(exp_report_p->packet_dest_addr,
                                             pktaddrbuf, sizeof(pktaddrbuf)));

                        switch(version) {
                        case 1:
                            break;

                        case 2:
                            exp_report2_p = 
                                (exp_rtcp_report_header2_t*)exp_report_p;
                            printf("    packet_src_addr:  %s \n", 
                                   uint32_ntoa_r(
                                       exp_report2_p->packet_src_addr,
                                       pktaddrbuf, sizeof(pktaddrbuf)));
                            printf("    packet_dest_port: %u \n", 
                                   ntohs(exp_report2_p->packet_dest_port));
                            printf("    packet_src_port:  %u \n\n", 
                                   ntohs(exp_report2_p->packet_src_port));

                            break;

                        default:
                            printf("Unrecognized Proprietary Header "
                                   "Version (%u)\n", version);
                            break;
                        }
                    } else {
                        printf("  Hdr: flags 0x%x; stream_type %u, "
                               "stream_dest %s:%u, pkt_dest %s\n",
                               exp_report_p->ver_flags,
                               exp_report_p->stream_type,
                               uint32_ntoa_r(exp_report_p->stream_dest_addr,
                                             straddrbuf, sizeof(straddrbuf)),
                               ntohs(exp_report_p->stream_dest_port),
                               uint32_ntoa_r(exp_report_p->packet_dest_addr,
                                             pktaddrbuf, sizeof(pktaddrbuf)));
                    }

                    length = (version == 1 ? sizeof(exp_rtcp_report_header_t) :
                              sizeof(exp_rtcp_report_header2_t));
                    rtcp_packet_p = ((char*)exp_report_p) + length;
                    rtcp_packet_len = bytes_received - length;

                    printf("  Standard Packet:\n\n");
                    rtcp_print_packet((rtcptype*)rtcp_packet_p, 
                                      rtcp_packet_len);
		
                } else {
                
                    if (verbose) {
                        printf("RTCP Compound Packet - contents filtered\n");
                    }
                }
		    
                break;
		    
            case EXP_BASE_TYPE_MISSED_REPORTS:
	    
                printf("Missed Compound Packets:\n");
                if (exp_base.ver_flags == EXP_BASE_VER_FLAGS) {
                    exp_missed_old_p = (exp_missed_reports_t*)rcvbuf;
                    printf("  Num_reports_missing: %llu ", 
                           exp_missed_old_p->num_reports_missing );

                } else {
                    exp_missed_p = (exp_missed_reports_v2_t*)rcvbuf;
                    missed_hi = ntohl(exp_missed_p->num_reports_missing_hi);
                    missed_lo = ntohl(exp_missed_p->num_reports_missing_lo);

                    printf("  Num_reports_missing_hi: %u \n", missed_hi);
                    printf("  Num_reports_missing_lo: %u \n", missed_lo);

                    missed = missed_hi;
                    missed = missed << 32;
                    missed |= missed_lo;
                    printf("  Num_reports_missing:    %llu ", missed);
                }

                break;

            default:
                printf("Unrecognized Common Header Type (%d)\n", 
                       exp_base.type);
                break;
            }
        }

        /* Write to the file */
        if (fp) {
            pkt_len = pcap_len + OVER_HEAD;
            if (max_pcap_size_used + pkt_len < max_pcap_size_allowed) {
                pcap_ret = vqe_pcap_udp_write(fp, pcapbuf, pcap_len);
                if (pcap_ret != VQE_PCAP_SUCCESS) {
                    fprintf(stderr, "Error of writing to the pcap file %d\n",
                            pcap_ret);
                    if (vqe_pcap_close_file(fp) != VQE_PCAP_SUCCESS) {
                        fprintf(stderr, "Error of closing the pcap file\n");
                    }
                    fp = 0;
                }
                max_pcap_size_used += pkt_len;
            } else {
                printf("Importer: The pcap file has reached the max size "
                       "allowed %llu.\n", max_pcap_size_allowed);
                if (vqe_pcap_close_file(fp) != VQE_PCAP_SUCCESS) {
                    fprintf(stderr, "Error of closing the pcap file\n");
                }
                fp = 0;

                goto done;
            }
        }
    }

 done:
    printf("\nImporter-%d: exiting now.\n", instance);
    close(new_fd);
    exit(-1);
}		
