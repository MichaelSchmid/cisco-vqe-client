/*
 *------------------------------------------------------------------
 * VAM Configuration Generator
 *
 * May 2006, Dong Hsu
 *
 * Copyright (c) 2006-2008 by Cisco Systems, Inc.
 * All rights reserved.
 *------------------------------------------------------------------
 */

/* System Includes */
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <resolv.h>

/* Application Includes */
#include <utils/vam_time.h>
#include "cfg_database.h"

const char *applicationUsage = "init_data_file";
#define SIZE 10
#define STATIC_PT 33
#define RE_SRC_PT 96
#define RTX_PT 97
#define FEC_COL_PT 98
#define FEC_ROW_PT 99

#define RR_VALUE 53
#define MAX_RCVRS 10000


int main (int argc, char *argv[])
{
    FILE *file_p;
    char hostname[MAX_LINE_LENGTH];
    char line_buffer[MAX_LINE_LENGTH];

    int i;
    int total_channels = 0;
    char role[SIZE];
    char mode[SIZE];
    char name[SDP_MAX_STRING_LEN];
    char desc[SDP_MAX_STRING_LEN];
    char session_id[SDP_MAX_STRING_LEN];
    char version[SDP_MAX_STRING_LEN];
    char session_key[MAX_KEY_LENGTH];
    char source_proto[SIZE];
    char original_addr[MAX_IP_ADDR_CHAR];
    int  original_port;
    char src_addr_for_original[MAX_IP_ADDR_CHAR];
    int  bit_rate;
    
    char re_sourced_addr[MAX_IP_ADDR_CHAR];
    int  re_sourced_rtp_port;

    char fbt_addr[MAX_IP_ADDR_CHAR];
    int  rtx_rtp_port;

    char fec_col_addr[MAX_IP_ADDR_CHAR];
    int  fec_col_port;

    char fec_row_addr[MAX_IP_ADDR_CHAR];
    int  fec_row_port;

    char status1[SIZE], status2[SIZE], status3[SIZE];
    char rtcp_fb_control1[RTCP_FB_CTL_SIZE];
    char rtcp_fb_control2[RTCP_FB_CTL_SIZE];
    char group[GROUP_SIZE];
    char fec_group[GROUP_SIZE];
    char rtcp_nack_msg[RTCP_NACK_MSG_SIZE];
    char rtcp_nack_pli_msg[RTCP_NACK_MSG_SIZE];
    char fec_session[FEC_SESSION_SIZE];

    char orig_rs_bw[BW_SIZE];
    char orig_rr_bw[BW_SIZE];
    char orig_per_rcvr_bw[BW_SIZE];
    char rtx_rs_bw[BW_SIZE];
    char rtx_rr_bw[BW_SIZE];

    /* Process the command line arguments */
    if (argc < 2) {
        printf( "\nUsage: %s %s\n", argv[0], applicationUsage);
        exit(-1);
    }

    file_p = fopen(argv[1], "read");
    if (file_p == NULL) {
        printf("Could not open the file %s for write\n",
               argv[1]);

        exit(-1);
    }
    
    /* Generate the configuration data */
    if (gethostname(hostname, MAX_LINE_LENGTH) != 0 ) {
        strncpy(hostname, "iptv.cisco.com", MAX_LINE_LENGTH);
    }
    else {
        if (res_init() == 0) {
            strncat(hostname, ".", MAX_LINE_LENGTH);
            strncat(hostname, _res.defdname, MAX_LINE_LENGTH);
        }
        else {
            strncat(hostname, ".cisco.com", MAX_LINE_LENGTH);
        }
    }
    

    printf("#\n");
    printf("# Channel configuration generated by the gen_cfg tool \n");
    printf("#\n\n");

    i = 1;
    while (fgets(line_buffer, MAX_LINE_LENGTH, (FILE *) file_p) != NULL) {
        if (line_buffer[0] != '#' && line_buffer[0] != '\n' &&
            line_buffer[0] != '\r' && line_buffer[0] != ' ') {
            if (total_channels == 0) {
                if (sscanf(line_buffer, "%d", &total_channels) == 0) {
                    printf("Error reading the input file %s\n", argv[1]);
                    exit(-1);
                }
            }
            else {
                if (sscanf(line_buffer, "%10s %10s %20s %d %20s %d "
                           "%20s %d %20s %d %20s %d %20s %d",
                           role, mode, original_addr, &original_port,
                           src_addr_for_original, &bit_rate, re_sourced_addr,
                           &re_sourced_rtp_port, fbt_addr, &rtx_rtp_port,
                           fec_col_addr, &fec_col_port,
                           fec_row_addr, &fec_row_port) == 0) {
                    printf("Error reading the input file %s\n", argv[1]);
                    exit(-1);
                }

                printf("#\n");
                printf("# Channel %d configuration\n", i);
                printf("#\n");

                memset(group, 0, GROUP_SIZE);
                if (strcmp(role, "ssm_ds") == 0) {
                    strncpy(source_proto, "RTP/AVP", SIZE);
                    strncpy(status1, "sendonly", SIZE);
                    strncpy(status2, "inactive", SIZE);
                    strncpy(status3, "inactive", SIZE);
                }
                else if (strcmp(role, "vam") == 0) {
                    if (strcmp(mode, "source") == 0) {
                        strncpy(source_proto, "udp", SIZE);
                        strncpy(status1, "recvonly", SIZE);
                        strncpy(status2, "sendonly", SIZE);
                        strncpy(status3, "sendonly", SIZE);
                        snprintf(group, GROUP_SIZE, GROUP, "2 3");
                    }
                    else if (strcmp(mode, "lookaside") == 0) {
                        strncpy(source_proto, "RTP/AVPF", SIZE);
                        strncpy(status1, "recvonly", SIZE);
                        strncpy(status2, "inactive", SIZE);
                        strncpy(status3, "sendonly", SIZE);
                        snprintf(group, GROUP_SIZE, GROUP, "1 3");
                    }
                    else {
                        printf("Wrong mode in the input file %s\n",
                               mode);
                        printf("%s\n", line_buffer);
                        exit(-1);
                    }
                }
                else if (strcmp(role, "stb") == 0) {
                    if (strcmp(mode, "source") == 0) {
                        strncpy(source_proto, "udp", SIZE);
                        strncpy(status1, "inactive", SIZE);
                        strncpy(status2, "recvonly", SIZE);
                        strncpy(status3, "recvonly", SIZE);
                        snprintf(group, GROUP_SIZE, GROUP, "2 3");
                    }
                    else if (strcmp(mode, "lookaside") == 0) {
                        strncpy(source_proto, "RTP/AVPF", SIZE);
                        strncpy(status1, "recvonly", SIZE);
                        strncpy(status2, "inactive", SIZE);
                        strncpy(status3, "recvonly", SIZE);
                        snprintf(group, GROUP_SIZE, GROUP, "1 3");
                    }
                    else {
                        printf("Wrong mode in the input file "
                               "%s!!!\n",
                               mode);
                        printf("%s\n", line_buffer);
                        exit(-1);
                    }
                }

                memset(rtcp_fb_control1, 0, RTCP_FB_CTL_SIZE);
                memset(rtcp_fb_control2, 0, RTCP_FB_CTL_SIZE);
                memset(rtcp_nack_msg, 0, RTCP_NACK_MSG_SIZE);
                memset(rtcp_nack_pli_msg, 0, RTCP_NACK_MSG_SIZE);
                if (strcmp(mode, "source") == 0) {
                    if (strcmp(role, "ssm_ds") != 0) {
                        snprintf(rtcp_nack_msg,
                                 RTCP_NACK_MSG_SIZE,
                                 RTCP_NACK_MSG,
                                 STATIC_PT);
                        snprintf(rtcp_nack_pli_msg,
                                 RTCP_NACK_MSG_SIZE,
                                 RTCP_NACK_PLI_MSG,
                                 STATIC_PT);
                        snprintf(rtcp_fb_control2,
                                 RTCP_FB_CTL_SIZE,
                                 RTCP_FB_CTL,
                                 re_sourced_rtp_port+1,
                                 fbt_addr,
                                 rtcp_nack_msg,
                                 rtcp_nack_pli_msg);
                    }
                    else {
                        snprintf(rtcp_fb_control1,
                                 RTCP_FB_CTL_SIZE,
                                 "a=rtcp:%d\n",
                                 RE_SRC_PT);
                    }
                }
                else if (strcmp(mode, "lookaside") == 0) {
                    snprintf(rtcp_nack_msg,
                             RTCP_NACK_MSG_SIZE,
                             RTCP_NACK_MSG,
                             RE_SRC_PT);
                    snprintf(rtcp_nack_pli_msg,
                             RTCP_NACK_MSG_SIZE,
                             RTCP_NACK_PLI_MSG,
                             RE_SRC_PT);
                    snprintf(rtcp_fb_control1,
                             RTCP_FB_CTL_SIZE,
                             RTCP_FB_CTL,
                             original_port+1,
                             fbt_addr,
                             rtcp_nack_msg,
                             rtcp_nack_pli_msg);
                }

                memset(fec_session, 0, FEC_SESSION_SIZE);
                memset(fec_group, 0, GROUP_SIZE);
                if (strcmp(fec_col_addr, "0.0.0.0") != 0) {
                    snprintf(fec_session, FEC_SESSION_SIZE,
                             FEC_SESSION,
                             fec_col_port,
                             FEC_COL_PT,
                             fec_col_addr,
                             (strcmp(role, "stb") == 0) ? 
                             "recvonly" : "sendonly",
                             fec_col_addr,
                             src_addr_for_original,
                             FEC_COL_PT,
                             "2dparityfec",
                             fec_col_port+1,
                             fec_row_port,
                             FEC_ROW_PT,
                             fec_row_addr,
                             (strcmp(role, "stb") == 0) ? 
                             "recvonly" : "sendonly",
                             fec_row_addr,
                             src_addr_for_original,
                             FEC_ROW_PT,
                             "2dparityfec",
                             fec_row_port+1);

                    if (strcmp(mode, "source") == 0) {
                        snprintf(fec_group, GROUP_SIZE, FEC_GROUP, "2 4 5");
                    }
                    else if (strcmp(mode, "lookaside") == 0) {
                        snprintf(fec_group, GROUP_SIZE, FEC_GROUP, "1 4 5");
                    }
                }                         
                         
                memset(orig_rs_bw, 0, BW_SIZE);
                snprintf(orig_rs_bw, BW_SIZE, RS_BW, RR_VALUE);

                memset(orig_rr_bw, 0, BW_SIZE);
                snprintf(orig_rr_bw, BW_SIZE, RR_BW, RR_VALUE*MAX_RCVRS);
                
                memset(orig_per_rcvr_bw, 0, BW_SIZE);
                snprintf(orig_per_rcvr_bw, BW_SIZE, PER_RCVR_BW,
                         RE_SRC_PT, RR_VALUE);

                memset(rtx_rs_bw, 0, BW_SIZE);
                snprintf(rtx_rs_bw, BW_SIZE, RS_BW, RR_VALUE);

                memset(rtx_rr_bw, 0, BW_SIZE);
                snprintf(rtx_rr_bw, BW_SIZE, RR_BW, RR_VALUE);

                snprintf(name, SDP_MAX_STRING_LEN, "Channel %s",
                         original_addr);
                snprintf(desc, SDP_MAX_STRING_LEN, "channel %d", i);
                snprintf(session_id, SDP_MAX_STRING_LEN, "%llu",
                         abs_time_to_sec(ntp_to_abs_time(get_ntp_time()))+i);
                snprintf(version, SDP_MAX_STRING_LEN, "%llu",
                         abs_time_to_sec(ntp_to_abs_time(get_ntp_time())));

                /*
                 * For the original stream:
                 *
                 * b=RS:<rs_val>
                 * b=RR:<rr_val>
                 * a=fmtp:rtcp-per-rcvr-bw:<prbw_val>
                 *
                 * where <rs_val> is 1.25% of the "b=AS:<as_val>" value, 
                 * <rr_val> is 3.75% of <as_val>, and <prbw_val> is 1/3750
                 * of the rr_val. 
                 *
                 * Note that as_val is in kbits/sec, but rs_val, rr_val and 
                 * prbw_val are all in bits/sec. Namely:
                 *
                 * rs_val = as_val * 1000 * .0125
                 *        = as_val * 12.5
                 *
                 * rr_val = as_val * 1000 * .0375
                 *        = as_val * 37.5
                 *
                 * prbw_val = rr_val / 3750
                 *          = as_val * 37.5 / 3750
                 *          = as_val / 100
                 *
                 * where 3750 is a somewhat arbitrary group size chosen to  
                 * make the arithmetic simple.
                 *
                 * For the repair stream:
                 *
                 * b=RS:<prbw_val>
                 * b=RR:<prbw_val>
                 *
                 */
                snprintf(session_key, MAX_KEY_LENGTH, "o=- %s %s IN IP4 %s",
                         session_id, version, hostname);


                printf(SDP_TEMPLATE,
                       session_key,
                       name,
                       desc,
                       group,
                       fec_group,
                       original_port,
                       source_proto,
                       RE_SRC_PT,
                       original_addr,
                       bit_rate,
                       orig_rs_bw,
                       orig_rr_bw,
                       orig_per_rcvr_bw,
                       status1,
                       original_addr,
                       src_addr_for_original,
                       RE_SRC_PT,
                       rtcp_fb_control1,
                       re_sourced_rtp_port,
                       STATIC_PT,
                       re_sourced_addr,
                       orig_rs_bw,
                       orig_rr_bw,
                       status2,
                       re_sourced_addr,
                       fbt_addr,
                       STATIC_PT,
                       rtcp_fb_control2,
                       rtx_rtp_port,
                       RTX_PT,
                       fbt_addr,
                       rtx_rs_bw,
                       rtx_rr_bw,
                       status3,
                       RTX_PT,
                       rtx_rtp_port+1,
                       RTX_PT,
                       (strcmp(mode, "source") == 0 ) ? STATIC_PT : RE_SRC_PT,
                       RTX_PT,
                       3000,
                       fec_session);
                
                i++;

                if (i != total_channels+1) {
                    printf("%s", SESSION_SEPARATOR);
                }
            }
        }
    }

    fclose(file_p);
    exit(0);
}

